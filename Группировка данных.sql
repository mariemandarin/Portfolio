-- Источник заданий: Симулятор SQL Karpov Courses --

--Группировка данных--
/* Задание 1
С помощью оператора `GROUP BY` посчитайте количество курьеров мужского и женского пола в таблице `couriers`.
Новую колонку с числом курьеров назовите `couriers_count`.
Результат отсортируйте по этой колонке по возрастанию. */

-- Решение:
SELECT
sex,
count(courier_id) couriers_count
FROM   couriers
GROUP BY sex
ORDER BY 2

----------------------------------------------------------------------------
/* Задание 2
Посчитайте количество созданных и отменённых заказов в таблице `user_actions`.
Новую колонку с числом заказов назовите `orders_count`.
Результат отсортируйте по числу заказов по возрастанию. */

-- Решение:
SELECT 
action,
count(order_id) orders_count
FROM   user_actions
GROUP BY action
ORDER BY 2

----------------------------------------------------------------------------
/* Задание 3
Используя группировку и функцию `DATE_TRUNC`, приведите все даты к началу месяца и посчитайте, сколько заказов было сделано в каждом из них.

Расчёты проведите по таблице `orders`. Колонку с усечённой датой назовите `month`, колонку с количеством заказов — `orders_count`.

Результат отсортируйте по месяцам — по возрастанию. */

-- Решение:
SELECT 
date_trunc('month', creation_time) as month,
count(order_id) orders_count
FROM   orders
GROUP BY month
ORDER BY 1 asc

----------------------------------------------------------------------------
/* Задание 4
Используя группировку и функцию `DATE_TRUNC`, приведите все даты к началу месяца и посчитайте, сколько заказов было сделано и сколько было отменено в каждом из них.

В этот раз расчёты проведите по таблице `user_actions`. Колонку с усечённой датой назовите `month`, колонку с количеством заказов — `orders_count`.

Результат отсортируйте сначала по месяцам — по возрастанию, затем по типу действия — тоже по возрастанию. */

-- Решение: 
SELECT 
date_trunc('month', time) as month,
action,
count(order_id) orders_count
FROM   user_actions
GROUP BY month, action
ORDER BY 1, 2

----------------------------------------------------------------------------
/* Задание 5
По данным в таблице `users` посчитайте максимальный порядковый номер месяца среди всех порядковых номеров месяцев рождения пользователей сервиса. С помощью группировки проведите расчёты отдельно в двух группах — для пользователей мужского и женского пола.

Новую колонку с максимальным порядковым номером месяца рождения в группах назовите `max_month`. Преобразуйте значения в новой колонке в формат `INTEGER`, чтобы порядковый номер был выражен целым числом.

Результат отсортируйте по колонке с полом пользователей. */

-- Решение:
SELECT 
sex,
max(date_part('month', birth_date))::int max_month
FROM   users
GROUP BY sex

----------------------------------------------------------------------------
/* Задание 6
По данным в таблице `users` посчитайте порядковый номер месяца рождения самого молодого пользователя сервиса. С помощью группировки проведите расчёты отдельно в двух группах — для пользователей мужского и женского пола.

Новую колонку c порядковым номером месяца рождения самого молодого пользователя в группах назовите `max_month`. Преобразуйте значения в новой колонке в формат `INTEGER`, чтобы порядковый номер был выражен целым числом.

Результат отсортируйте по колонке с полом пользователей. */

-- Решение:
SELECT 
sex,
date_part('month', max(birth_date))::int max_month
FROM   users
GROUP BY sex

----------------------------------------------------------------------------
/* Задание 7
Посчитайте максимальный возраст пользователей мужского и женского пола в таблице `users`. Возраст измерьте числом полных лет.

Новую колонку с возрастом назовите `max_age`. Преобразуйте значения в новой колонке в формат `INTEGER`, чтобы возраст был выражен целым числом.

Результат отсортируйте по новой колонке по возрастанию возраста. */

-- Решение:
SELECT 
sex,
((current_date - min(birth_date))/365)::varchar max_age
FROM   users
GROUP BY sex

----------------------------------------------------------------------------
/* Задание 8
Разбейте пользователей из таблицы `users` на группы по возрасту (возраст по-прежнему измеряем числом полных лет) и посчитайте количество пользователей каждого возраста.

Колонку с возрастом назовите `age`, а колонку с числом пользователей — `users_count`. Преобразуйте значения в колонке с возрастом в формат `INTEGER`, чтобы возраст был выражен целым числом.

Результат отсортируйте по колонке с возрастом по возрастанию. */

-- Решение:
SELECT 
date_part('year', age(birth_date))::integer as age,
count(user_id) users_count
FROM   users
GROUP BY age
ORDER BY age

----------------------------------------------------------------------------
/* Задание 9
Вновь разбейте пользователей из таблицы `users` на группы по возрасту (возраст по-прежнему измеряем количеством полных лет), только теперь добавьте в группировку ещё и пол пользователя. Затем посчитайте количество пользователей в каждой половозрастной группе.

Все `NULL` значения в колонке `birth_date` заранее отфильтруйте с помощью `WHERE`.
Колонку с возрастом назовите `age`, а колонку с числом пользователей — `users_count`, имя колонки с полом оставьте без изменений. Преобразуйте значения в колонке с возрастом в формат `INTEGER`, чтобы возраст был выражен целым числом.

Отсортируйте полученную таблицу сначала по колонке с возрастом по возрастанию, затем по колонке с полом — тоже по возрастанию. */

-- Решение:
SELECT 
date_part('year', age(birth_date))::integer as age,
sex,
count(user_id) users_count
FROM   users
WHERE  birth_date is not null
GROUP BY age, sex
ORDER BY age, sex

----------------------------------------------------------------------------
/* Задание 10
Посчитайте количество товаров в каждом заказе, примените к этим значениям группировку и рассчитайте количество заказов в каждой группе за неделю с 29 августа по 4 сентября 2022 года включительно. Для расчётов используйте данные из таблицы `orders`.

Выведите две колонки: размер заказа и число заказов такого размера за указанный период. Колонки назовите соответственно `order_size` и `orders_count`.

Результат отсортируйте по возрастанию размера заказа. */

-- Решение:
SELECT
array_length(product_ids, 1) order_size,
count(order_id) orders_count
FROM   orders
WHERE  creation_time between '2022-08-29' and '2022-09-05'
GROUP BY order_size
ORDER BY 1

----------------------------------------------------------------------------
/* Задание 11
Посчитайте количество товаров в каждом заказе, примените к этим значениям группировку и рассчитайте количество заказов в каждой группе. Учитывайте только заказы, оформленные по будням. В результат включите только те размеры заказов, общее число которых превышает 2000. Для расчётов используйте данные из таблицы `orders`.
Выведите две колонки: размер заказа и число заказов такого размера. Колонки назовите соответственно `order_size` и `orders_count`.

Результат отсортируйте по возрастанию размера заказа.

Когда решите эту задачу, вернитесь к одной из предыдущих  и подумайте, могли бы мы ещё каким-то способом сделать так, чтобы в результат не попала группа с `NULL` значениями. Можете самостоятельно написать ещё один запрос и попробовать сдать его в качестве альтернативного решения. */

-- Решение:
SELECT 
array_length(product_ids, 1) order_size,
count(order_id) orders_count
FROM   orders
WHERE  date_part('dow', creation_time) not in (6, 0)
GROUP BY order_size 
HAVING count(order_id) > 2000
ORDER BY 1

----------------------------------------------------------------------------
/* Задание 12
По данным из таблицы `user_actions` определите пять пользователей, сделавших в августе 2022 года наибольшее количество заказов.

Выведите две колонки — id пользователей и число оформленных ими заказов. Колонку с числом оформленных заказов назовите `created_orders`.

Результат отсортируйте сначала по убыванию числа заказов, сделанных пятью пользователями, затем по возрастанию id этих пользователей.*/

-- Решение:
SELECT 
user_id,
count(order_id) created_orders
FROM   user_actions
WHERE  action != 'cancel_order' and date_part('month', time) = 8
GROUP BY user_id
ORDER BY 2 desc, 1 asc limit 5

----------------------------------------------------------------------------
/* Задание 13
А теперь по данным таблицы `courier_actions` определите курьеров, которые в сентябре 2022 года доставили только по одному заказу.
В этот раз выведите всего одну колонку с id курьеров. Колонку с числом заказов в результат включать не нужно.

Результат отсортируйте по возрастанию id курьера. */

-- Решение:
SELECT courier_id
FROM courier_actions
WHERE  action = 'deliver_order' and date_part('month', time) = 9
GROUP BY courier_id having count(order_id) = 1
ORDER BY 1 asc

----------------------------------------------------------------------------
/* Задание 14:
Из таблицы `user_actions` отберите пользователей, у которых последний заказ был создан до 8 сентября 2022 года.
Выведите только их id, дату создания заказа выводить не нужно.

Результат отсортируйте по возрастанию id пользователя. */

-- Решение:
SELECT user_id
FROM   user_actions
WHERE  action = 'create_order'
GROUP BY user_id having max(time) < '2022-09-08'
ORDER BY 1 asc

----------------------------------------------------------------------------
/* * Задание 15:
Разбейте заказы из таблицы `orders` на 3 группы в зависимости от количества товаров, попавших в заказ:
- Малый (от 1 до 3 товаров);
- Средний (от 4 до 6 товаров);
- Большой (7 и более товаров).

Посчитайте число заказов, попавших в каждую группу. Группы назовите соответственно `«Малый»`, `«Средний»`, `«Большой»` (без кавычек).
Выведите наименования групп и число товаров в них. Колонку с наименованием групп назовите `order_size`, а колонку с числом заказов — `orders_count`.

Отсортируйте полученную таблицу по колонке с числом заказов по возрастанию. */

-- Решение:
SELECT 
(case when array_length(product_ids, 1) between 1 and 3 then 'Малый'
	  when array_length(product_ids, 1) between 4 and 6 then 'Средний'
	  when array_length(product_ids, 1) >= 7 then 'Большой'
	  else '' end) as order_size,
count(order_id) orders_count
FROM   orders
GROUP BY order_size
ORDER BY 2

----------------------------------------------------------------------------
/* * Задание 16:
Разбейте пользователей из таблицы `users` на 4 возрастные группы:
- от 18 до 24 лет;
- от 25 до 29 лет;
- от 30 до 35 лет;
- не младше 36.

Посчитайте число пользователей, попавших в каждую возрастную группу. Группы назовите соответственно `«18-24»`, `«25-29»`, `«30-35»`, `«36+»` (без кавычек).
В расчётах не учитывайте пользователей, у которых не указана дата рождения. Как и в прошлых задачах, в качестве возраста учитывайте число полных лет.
Выведите наименования групп и число пользователей в них. Колонку с наименованием групп назовите `group_age`, а колонку с числом пользователей — `users_count`.

Отсортируйте полученную таблицу по колонке с наименованием групп по возрастанию. */

-- Решение:
SELECT 
(case when date_part('year', age(birth_date))::integer >= 36 then '36+'
             when date_part('year', age(birth_date))::integer between 30 and 35 then '30-35'
             when date_part('year', age(birth_date))::integer between 25 and 29 then '25-29'
             when date_part('year', age(birth_date))::integer between 18 and 24 then '18-24'
             else '' end) group_age ,
count(user_id) users_count
FROM   users
WHERE  birth_date is not null
GROUP BY group_age
ORDER BY 1

----------------------------------------------------------------------------
/* * Задание 17:
По данным из таблицы `orders` рассчитайте средний размер заказа по выходным и будням.
Группу с выходными днями (суббота и воскресенье) назовите «weekend», а группу с будними днями (с понедельника по пятницу) — «weekdays» (без кавычек).
В результат включите две колонки: колонку с группами назовите `week_part`, а колонку со средним размером заказа — `avg_order_size`. 
Средний размер заказа округлите до двух знаков после запятой.

Результат отсортируйте по колонке со средним размером заказа — по возрастанию. */

-- Решение:
SELECT 
(case when date_part('dow', creation_time) between 1 and 5 then 'weekdays'
else 'weekend' end) as week_part,
round(avg(array_length(product_ids, 1)), 2) avg_order_size
FROM   orders
GROUP BY week_part
ORDER BY 2

----------------------------------------------------------------------------
/* ** Задание 18:
Для каждого пользователя в таблице `user_actions` посчитайте общее количество оформленных заказов и долю отменённых заказов.

Новые колонки назовите соответственно `orders_count` и `cancel_rate`. Колонку с долей отменённых заказов округлите до двух знаков после запятой.
В результат включите только тех пользователей, которые оформили больше трёх заказов и у которых показатель cancel_rate составляет не менее 0.5.

Результат отсортируйте по возрастанию id пользователя. */

-- Решение:
SELECT 
user_id,
(count(order_id) filter (WHERE action = 'cancel_order'))/(count(order_id) filter (WHERE action = 'create_order')::decimal) cancel_rate,
count(distinct order_id) orders_count
FROM   user_actions
GROUP BY user_id 
HAVING count(distinct order_id) > 3 and (count(order_id) filter (WHERE  action = 'cancel_order'))/(count(order_id) filter (WHERE  action = 'create_order'))::decimal >= 0.5
ORDER BY user_id

----------------------------------------------------------------------------
/* ** Задание 19:
Для каждого дня недели в таблице `user_actions` посчитайте:

1. Общее количество оформленных заказов.
2. Общее количество отменённых заказов.
3. Общее количество неотменённых заказов (т.е. доставленных).
4. Долю неотменённых заказов в общем числе заказов (success rate).

Новые колонки назовите соответственно `created_orders`, `canceled_orders`, `actual_orders` и `success_rate`. Колонку с долей неотменённых заказов округлите до трёх знаков после запятой.

Все расчёты проводите за период с 24 августа по 6 сентября 2022 года включительно, чтобы во временной интервал попало равное количество разных дней недели.

Группы сформируйте следующим образом: выделите день недели из даты с помощью функции `to_char` с параметром 'Dy', также выделите порядковый номер дня недели с помощью функции `DATE_PART` с параметром 'isodow'. Далее сгруппируйте данные по двум полям и проведите все необходимые расчёты.

В результате должна получиться группировка по двум колонкам: с порядковым номером дней недели и их сокращёнными наименованиями.

Результат отсортируйте по возрастанию порядкового номера дня недели. */

-- Решение:
SELECT 
(case when date_part('dow', time) = 0 then '7'
else date_part('dow', time) end)::int weekday_number,
to_char(time, 'Dy') weekday,
count(distinct order_id) filter(WHERE action = 'create_order') created_orders,
count(distinct order_id) filter(WHERE action = 'cancel_order') canceled_orders,
count(distinct order_id) filter(WHERE action = 'create_order') - count(distinct order_id) filter(WHERE action = 'cancel_order') actual_orders,
round(1 - (count(distinct order_id) filter (WHERE action = 'cancel_order')::decimal / count(distinct order_id) filter(WHERE action = 'create_order')::decimal), 1) success_rate
FROM   user_actions
WHERE  time between '2022-08-24' and '2022-09-07'
GROUP BY weekday_number, weekday
ORDER BY weekday_number